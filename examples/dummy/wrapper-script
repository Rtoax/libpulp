#!/bin/bash

# Print the arguments when in debugging mode
if [ -v DEBUG ]
then
  printf "List of arguments send from make to the test wrapper:\n"
  for i in `seq 0 $#`
  do
    printf "arg #$i: '${!i}'\n"
  done
fi

# Sleep for SLEEP_AMOUNT seconds before applying the live pacthes or
# before killing the application to let it print its message to the log
# file.  A value of 0 will prevent most, if not all, messages from being
# printed, which might make it harder to debug, but allows for faster
# execution of 'make check'.
SLEEP_AMOUNT=0

# Makefile.am uses the variables TESTS and AM_LOG_FLAGS to control the
# execeution of libpulp tests, as follows:
#   TESTS:
#     Lists the test program that must be executed by this script.  For
#     each item in TESTS, this script is called once.
#   AM_LOG_FLAGS:
#     Lists additional parameters to be passed to this script, apart
#     from the name of the test program (defined in TESTS), which comes
#     as the last argument.  Currently, AM_LOG_FLAGS only adds the path
#     to the top-level build directory ($(abs_top_builddir)), which is
#     enough to derive the names of the other files (libulp.so and
#     ulp_trigger) required to run the test cases.
builddir=$1
testcase=$2

# The dummy examples are supposed to be executed in two major steps:
#   1. start one of the dummy programs with libpulp preloaded;
#   2. use ulp_trigger, twice, to patch the program.

# Start the program and save its pid.
LD_PRELOAD=$builddir/lib/.libs/libulp.so $testcase &
testcase_pid=$!

# Patch the program twice.
patching_errors=0
for i in 1 2
do
  sleep $SLEEP_AMOUNT
  if ! $builddir/tools/trigger/ulp_trigger $testcase_pid metadata$i.ulp
  then
    printf "Live patch #$i failed to apply.\n"
    patching_errors=$(($patching_errors+1))
  fi
done

# Kill the test program.
sleep $SLEEP_AMOUNT
kill $testcase_pid

# Return an error code to the test driver.

# One or two errors means that one or both of the live patching attempts
# failed, so return 1 (failure).
if [ $patching_errors -eq 1 ] || [ $patching_errors -eq 2 ]
then
  exit 1
fi

# No errors means that both live patches applied successfully.
if [ $patching_errors -eq 0 ]
then
  exit 0
fi

# Anything different than that is unexpected, so return a hard error.
exit 99
