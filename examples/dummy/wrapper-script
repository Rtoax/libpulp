#!/bin/bash

# C/C++ error codes (error.h) returned by ulp_trigger and ulp_check.
EAGAIN=11

# Print the arguments when in debugging mode
if [ -v DEBUG ]
then
  printf "List of arguments send from make to the test wrapper:\n"
  for i in `seq 0 $#`
  do
    printf "arg #$i: '${!i}'\n"
  done
fi

# Sleep for SLEEP_AMOUNT seconds before applying the live pacthes or
# before killing the application to let it print its message to the log
# file.  A value of 0 will prevent most, if not all, messages from being
# printed, which might make it harder to debug, but allows for faster
# execution of 'make check'.
if [ ! -v SLEEP_AMOUNT ]
then
  SLEEP_AMOUNT=0
fi

# Makefile.am uses the variables TESTS and AM_LOG_FLAGS to control the
# execeution of libpulp tests, as follows:
#   TESTS:
#     Lists the test program that must be executed by this script.  For
#     each item in TESTS, this script is called once.
#   AM_LOG_FLAGS:
#     Lists additional parameters to be passed to this script, apart
#     from the name of the test program (defined in TESTS), which comes
#     as the last argument.  Currently, AM_LOG_FLAGS only adds the path
#     to the top-level build directory ($(abs_top_builddir)), which is
#     enough to derive the names of the other files (libpulp.so and
#     ulp_trigger) required to run the test cases.
builddir=$1
testcase=$2

# The dummy examples are supposed to be executed in two major steps:
#   1. start one of the dummy programs with libpulp preloaded;
#   2. use ulp_trigger, twice, to patch the program.

# Start the program and save its pid.
LD_PRELOAD=$builddir/lib/.libs/libpulp.so $testcase &
testcase_pid=$!

# Patch the program twice.
patching_errors=0
for i in 1 2
do
  sleep $SLEEP_AMOUNT

  failed=0
  retry=0
  while [ $retry -lt 10 ]
  do
    $builddir/tools/trigger/ulp_trigger \
      $testcase_pid \
      libdummy_livepatch$i.ulp
    ret=$?
    if [ $ret -ne 0 ]
    then
      printf "Attempt $retry to apply live patch #$i failed "
      if [ $ret -eq 4 ] || [ $ret -eq $EAGAIN ]
      then
        printf "(ulp resources are not ready ($ret)). "
      else
        printf "(unknown error ($ret)). "
      fi
      printf "Try again later.\n"
      failed=1
    else
      printf "Live patch #$i applied successfully.\n"
      failed=0
      break
    fi
    retry=$(($retry+1))
    sleep $SLEEP_AMOUNT
  done

  if [ $failed -ne 0 ]
  then
    patching_errors=$(($patching_errors+1))
  fi
done

# Kill the test program.
sleep $SLEEP_AMOUNT
kill $testcase_pid

# Return an error code to the test driver.

# One or two errors means that one or both of the live patching attempts
# failed, so return 1 (failure).
if [ $patching_errors -eq 1 ] || [ $patching_errors -eq 2 ]
then
  exit 1
fi

# No errors means that both live patches applied successfully.
if [ $patching_errors -eq 0 ]
then
  exit 0
fi

# Anything different than that is unexpected, so return a hard error.
exit 99
