#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <ulp/alloc.h>
#include <ulp/alloc-internal.h>


/* XXX: How much memory is enough? */
#define REQUIRED_CAPACITY 1*1024*1024 /* 1 MB */

/* Handler for catching SIGSEGVs generated by write-after-free. */
void
handler (int sig,
         siginfo_t *info __attribute__ ((unused)),
         void *ucontext __attribute__ ((unused)))
{
  if (sig == SIGSEGV)
    exit (0);
}

/*
 * This test case tests several situations:
 *   - Page-boundary crossings;
 *   - Total memory capacity;
 *   - Clearing of the scratch arena;
 *   - Allocating after clearing.
 *   - Write after free (clear).
 */
int
main (void)
{
  int i;
  int size;
  int capacity;
  int *address;
  void *base;
  long offset;
  long page_size = sysconf (_SC_PAGESIZE);
  struct sigaction act;

  /* Allocate memory until capacity exhaustion. */
  capacity = 0;
  for (i = 0; ; i++) {
    /*
     * Allocating a random amount of memory would eventually lead to a
     * page-boundary cross, which should be detected by the allocator
     * and avoided. This potential problem is tested, further down, with
     * a call to memset.
     */
    size = (rand() % 0x10);

    /* Actual allocation. */
    address = ulp_alloc (get_scratch_arena(), size, &base, &offset);

    /* When address is NULL, assume capacity is exhausted. */
    if (address == NULL) {
      break;
    }

    /* Check if there has been a page boundary overrun. */
    else {
      if (offset + size >= page_size) {
        printf ("Error: Allocated beyond page boundary.\n");
        return 1;
      }
    }

    /*
     * Write to the newly allocated memory, which may lead to a
     * page-boundary cross and a segmentation fault.
     */
    memset (address, 0, size);

    /* Add size to the accumulator for later checking and reporting. */
    capacity += size;
  }

  /*
   * Check that the total capacity is as much as needed for meaningful
   * live patch usage.
   */
  if (capacity < REQUIRED_CAPACITY) {
    printf ("Total capacity (%d bytes) "
            "is less than the required (%d bytes).\n",
            capacity, REQUIRED_CAPACITY);
    return 1;
  }

  /*
   * Allocate space on the default arena, clear the scratch arena, then
   * test that the clear did unmap the default arena, as well.
   */
  address = ulp_default_alloc (sizeof (int));
  ulp_scratch_clear();
  *address = (int) 0;

  /* Try to allocate space on the previously cleared scratch arena. */
  address = ulp_scratch_alloc (sizeof (int));
  *address = (int) 0;

  /* Try a write after free (catch the signal and exit). */
  memset(&act, 0, sizeof(act));
  act.sa_sigaction = handler;
  act.sa_flags = SA_SIGINFO;
  errno = 0;
  if (sigaction(SIGSEGV, &act, NULL)) {
    perror("Unable to register handler for SIGSEGV.");
    return 1;
  }
  ulp_scratch_clear();
  *address = (int) 0;

  /* Should have exited through the signal handler. */
  return 1;
}
